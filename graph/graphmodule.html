<!DOCTYPE html>
<html>
	<head>
    <meta http-equiv="content-type" content = "text/html; charset= UTF-8"/>

	<script src="plotly.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="xml2json.js"></script>	
	
	<script>

	</script>
	</head>
	<body>
	<div class="navbar"><span>Real-Time Telemetry Data</span></div>
	<div class="wrapper">
		<div id="chart"></div>
		<script src="xml2json.js"></script>
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script>	
			console.log('start');
			var done = false;
			var keys = [];
			var numKeys = 0;
			var rawvalues = [];
			var keysValues = [];
			var json = "";
			//var myList = document.querySelector('ul');
			
			$.ajax({
				method: 'GET',
//WARNING: ALWAYS ADD/REMOVE API KEY
				url: 'https://cors-anywhere.herokuapp.com/https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?',
				success: function(html) {
					console.log('herokutest');
					console.log(html);
				}
			})
			
			var request = new Request(
//			'https://raw.githubusercontent.com/nlee806/temp/master/testdata.txt');
	// /locations/{observatories}/{timeRange}/{coordinateSystems}/ 
	// {observatories} = a comma separated list of observatory identifiers for which location data is being requested. The values must be from those returned by Get Observatories.
	//{timeRange} = time range for which data location is being requested. There must be two comma separated basic format (minimal number of separators) ISO 8601 date values.
	//{coordinateSystems} = a comma separated list of the names of the coordinate systems in which to represent the returned location information. The values must be from this list: geo, gm, gse, gsm, sm, geitod, geij2000. If no values are given, gse will be assumed. For each coordinate system, the X, Y, Z, Latitude, Longitude, and local-time (if applicable) values will be returned.
	//Satellite observatories: mms1,mms2
	//Time range: 20190101T000000Z,20190101T001000Z
	//Coordinate systems: gse,geo
//WARNING: ALWAYS ADD/REMOVE API KEY
			'https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?api_key=Pfpfhf3PZS8MhCZWRvwv81zI3ID6VoLJggVdWvvR');  
			//'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
			//app.get('/YourPath/:parameterName', 
			//function (req, res) {
			fetch(request)//, {mode: 'no-cors', headers: {'Access-Control-Allow-Origin':'*'}})//"same-origin"})//no-cors"})
//				.then(res => res.json())
				.then(res => res.text())
				.then(text => {
//				console.log(text);
			//from xmljson_test.html
			function parseXml(xml) {
				var dom = null;
				if (window.DOMParser) {
					try { 
						dom = (new DOMParser()).parseFromString(xml, "text/xml"); 
					} 
					catch (e) { dom = null; }
				}
				else if (window.ActiveXObject) {
					try {
						dom = new ActiveXObject('Microsoft.XMLDOM');
						dom.async = false;
						if (!dom.loadXML(xml)) // parse error ..
							window.alert(dom.parseError.reason + dom.parseError.srcText);
						} 
					catch (e) { dom = null; }
				}
				else
					alert("Error!");
					return dom;
				}
				json = xml2json(parseXml(text), "  ");
				console.log('jsontest');
				console.log(json);
				})
				.then((out) => {
					//--------------testdata2.json ---------------
					out = JSON.parse(json);
					//console.log(typeof(out));
					console.log(out.Response.Result[0]);
					console.log(out.Response.Result[1]);
					console.log(out.Response.Result[2]);
					//--------------testdata2.json-----------------
					//res.setHeader('Access-Control-Allow-Origin', 'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
					console.log('Status Code: ', out.Result.StatusCode);
					console.log('Status Sub Code: ', out.Result.StatusSubCode);
					keys = Object.keys(out.Result.Data[1][0]);
					console.log('keys = ', keys);
					numKeys = keys.length;
					console.log('numKeys = ', numKeys);
					rawvalues = Object.values(out.Result.Data[1][0]);
					console.log('values = ',rawvalues);
					for(var i=0;i<numKeys;i++){
						var currentrawvalue = rawvalues[i];
						var datarawvalue = [];
						if(keys[i]!="Id"){
							datarawvalue = currentrawvalue[currentrawvalue.length-1];
						}
						else{
							datarawvalue = currentrawvalue;
						}
						keysValues.push([keys[i], datarawvalue]);
					}
					console.log('KeysValues', keysValues);
					//console.log('Output: ', out);
					//myList = JSON.parse(out);
					//return res.json();
	//			})
	//			.catch(err => console.error(err));				
			var chartValuesFields = [];
			var sumChartValues = [];
			var chartValues = [];
			var chartValuesIndex = 0;
			console.log('testc');
			var totalxlength = 0;//500;
			var data = [];//[{y:[getData()], type: 'line'}, {y: [getData()],type: 'line'}, {y: [getData()],type: 'line'}];
			var finalKeyValues = [];
			var finalKeyValuesNum = 0;
			console.log('testd', keysValues[3][1][0]);
			for(var q=0;q<numKeys;q++){
				if(typeof keysValues[q][1][0]==='number'){ //must be numeric type
					if(keysValues[q][1].length>totalxlength){
						totalxlength = keysValues[q][1].length;
					}
					finalKeyValuesNum++;
					finalKeyValues.push(keysValues[q]);
					var counting = 0;
					//data array is initial points
					//for(int y=0;y<totalxlength;y++){ //<17 times
						var dataAdd = {y:[keysValues[q][1][0]], type: 'line'};
						data.push(dataAdd);
					//}
					var addToChartValuesFields = keysValues[q][0]; //may be redundant in for loop, only need once
					chartValuesFields.push(addToChartValuesFields);
					var addToChartValues = keysValues[q][1][0];
					chartValues.push(addToChartValues);
					//console.log('addToChartValuesFields', chartValuesFields);
					//console.log('addToChartValues', chartValues);
					
					//var para = document.createElement("td");
					//var node = document.createTextNode(chartValuesFields);
					//para.appendChild(node);
					//var para2 = document.createElement("p");
					//var node2 = document.createTextNode(chartValues);
					//para2.appendChild(node2);

				}
				//if "Coordinates" special case
			}
			chartValuesIndex++;
			chartValuesIndex++;
			for(var a=0;a<chartValuesFields.length;a++){
console.log('chartValuesFields length', chartValuesFields.length, 'chartValuesFields[a]', chartValuesFields[a]);
				var para = document.createElement("td");
				var node = document.createTextNode(chartValuesFields[a]);
				para.appendChild(node);
				sumChartValues.push(chartValuesFields);
				sumChartValues.push(chartValues);
				var element = document.getElementById("fieldnames");
				element.appendChild(para);
			}
			//element.appendChild(para2);
			console.log('sumChartValues initial', sumChartValues);
			
			Plotly.plot('chart', data);
			var cnt=0;
			var dataindex = 0;
			var multipleTraces = [];
			console.log('finalKeyValuesNum', finalKeyValuesNum);
			
			var indices = [];
			for (var w=0;w<finalKeyValuesNum;w++){
				indices.push(w);
			}
			console.log('indices', indices);
			setInterval(function(){
				multipleTraces = []; //clear
				var table = document.getElementById("traces");
				var row = table.insertRow(table.rows.length-1); //insert row at bottom
				for(var r=0;r<finalKeyValuesNum;r++){//<17 times down by column
					multipleTraces.push([getData(r, dataindex)]);
					
					if(r==finalKeyValuesNum-1){
						for(var a=0;a<multipleTraces.length;a++){
							var cellAdd = row.insertCell(a);
							cellAdd.innerHTML = (multipleTraces[a]);
							//var para3 = document.createElement("td");
							//var node3 = document.createTextNode(multipletraces[a]);
							//para3.appendChild(node3);
							//var element = document.getElementById("data");
							//element.appendChild(para3);
						}
					}
				//}	
				/*
				sumChartValues.push(multipleTraces);
				var para3 = document.createElement("td");
				var node3 = document.createTextNode(sumChartValues[r][1][dataindex]);
				para3.appendChild(node3);
				var element = document.getElementById("data");
				element.appendChild(para3);
				*/
				}

				
				//var para4 = document.createElement("tr");
				//var node4 = document.create
				//console.log('sumChartValues initial', sumChartValues);
				chartValuesIndex++;
				console.log('multpltraces', multipleTraces);
				/*var para1 = document.createElement("p");
				var node3 = document.createTextNode(addToChartValuesFields);
				para1.appendChild(node);
				var node4 = document.createTextNode(addToChartValues);
				para1.appendChild(node4);
				var element = document.getElementById("bottomchart");
				element.appendChild(para1);
				*///console.log('dataindex', dataindex);
				//console.log('multipleTraces',multipleTraces);
				Plotly.extendTraces('chart',{y:multipleTraces},indices)
				//Plotly.extendTraces('chart',{y:[[getData()]]},[0])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[1])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[2])
				dataindex++;
				cnt++;
				if(cnt>totalxlength){
					Plotly.relayout('chart', {
						xaxis: {
							range: [cnt-totalxlength, cnt]
						}
					});
				}
			},200); //update every 200 seconds.
			var keyIndex = 0;
			var valueIndex = 0;
			function getData(r, dataindex){//keyIndex, valueIndex){
				//for(int r=0;r<totalxlength;r++){ //30 times
				return finalKeyValues[r][1][dataindex];
					//var dataAdd = {y:[getData(q, keysValues[q][1][r])], type: 'line'};
					//data.push(dataAdd);
				//}
				//return Math.random();
			}
		})
				.catch(err => console.error(err));	
	//	}
		</script>
	</div>
	<div id = "bottomchart">
	<p>Table Chart</p>
	<table style="width:100%" id = "traces">
			<tr id = "fieldnames">
			</tr>
			<tr id = "data">
			</tr>
		</table>
	</div>
	</body>
</html>