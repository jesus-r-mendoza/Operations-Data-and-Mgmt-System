<!DOCTYPE html>
<html>
	<head>
    <meta http-equiv="content-type" content = "text/html; charset= UTF-8"/>

	<script src="plotly.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="xml2json.js"></script>	
	
	<script>

	</script>
	</head>
	<body>
	<div class="navbar"><span>Real-Time Telemetry Data</span></div>
	<div class="wrapper">
		<div id="chart"></div>
		<script src="xml2json.js"></script>
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script>	
			console.log('start');
			var done = false;
			var keys = [];
			var numKeys = 0;
			var rawvalues = [];
			var keysValues = [];
			var json = "";
			//var myList = document.querySelector('ul');
			
			$.ajax({
				method: 'GET',
//WARNING: ALWAYS ADD/REMOVE API KEY
				url: 'https://cors-anywhere.herokuapp.com/https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?',
				success: function(html) {
					console.log('herokutest');
					console.log(html);
				}
			})
			
			var request = new Request(
//			'https://raw.githubusercontent.com/nlee806/temp/master/testdata.txt'); //testType = 1
	// /locations/{observatories}/{timeRange}/{coordinateSystems}/ 
	// {observatories} = a comma separated list of observatory identifiers for which location data is being requested. The values must be from those returned by Get Observatories.
	//{timeRange} = time range for which data location is being requested. There must be two comma separated basic format (minimal number of separators) ISO 8601 date values.
	//{coordinateSystems} = a comma separated list of the names of the coordinate systems in which to represent the returned location information. The values must be from this list: geo, gm, gse, gsm, sm, geitod, geij2000. If no values are given, gse will be assumed. For each coordinate system, the X, Y, Z, Latitude, Longitude, and local-time (if applicable) values will be returned.
	//Satellite observatories: mms1,mms2
	//Time range: 20190101T000000Z,20190101T001000Z
	//Coordinate systems: gse,geo
//WARNING: ALWAYS ADD/REMOVE API KEY testType = 2
			'https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?');  
			//'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
			//app.get('/YourPath/:parameterName', 
			//function (req, res) {
			fetch(request)//, {mode: 'no-cors', headers: {'Access-Control-Allow-Origin':'*'}})//"same-origin"})//no-cors"})
//				.then(res => res.json()) //testType = 1
				.then(res => res.text()) //testType = 2
				.then(text => {
//				console.log(text);
			//from xmljson_test.html
			function parseXml(xml) {
				var dom = null;
				if (window.DOMParser) {
					try { 
						dom = (new DOMParser()).parseFromString(xml, "text/xml"); 
					} 
					catch (e) { dom = null; }
				}
				else if (window.ActiveXObject) {
					try {
						dom = new ActiveXObject('Microsoft.XMLDOM');
						dom.async = false;
						if (!dom.loadXML(xml)) // parse error ..
							window.alert(dom.parseError.reason + dom.parseError.srcText);
						} 
					catch (e) { dom = null; }
				}
				else
					alert("Error!");
					return dom;
				}
				json = xml2json(parseXml(text), "  ");
//				console.log('jsontest');
//				console.log(json);
				})
				.then((out) => {
					var testType = 2;
					//--------------testdata2.json ---------------
					if(testType==2){
					out = JSON.parse(json);
					//var stringJSON = JSON.stringify(out);
					//console.log(typeof(stringJSON));
					//console.log('stringJSON', stringJSON);
					//console.log(typeof(out));
					console.log(out.Response.Result[0]);
					console.log(out.Response.Result[1]);
					console.log(out.Response.Result[2]); //2->infinity observatories
					var observatories = [];
					var coordinates = [];
					//numObservatories = number of Datas
					var numObservatories = -2; // -1 to account for StatusCode, StatusSubCode
					var numCoordinates = 0;
					var id = "";
					var masterData = [];
					var masterType = [];
					var masterSubType = [];
					var masterTime = [];
					var masterRadialLength = [];
					var masterFields = [];
					var timeArray = [];
					var radialLengthArray = [];
					var coordinateSystems = [];
					var arrangeDataPoints = [];
					var masterDatatempArray = [];
					var masterSingleDataArray = [];
					var masterSingleDataArrayLength = 0;
					var firstKey = "";
					var dataLength = 0;
					var fieldCount = 0;
					var numDatas = out.Response.Result.length - 2;
					var coordinateLength = 0;
					console.log('numDatas', numDatas);
					console.log('out.Response.Result.length',out.Response.Result.length);
					console.log('out.Response.Result[2].Data.length',out.Response.Result[2].Data.length);
					
					for(var a=0;a<out.Response.Result.length;a++){ //0123
						if(a>=2){// if, only if is DataArray
							for(var b=0;b<out.Response.Result[a].Data.length;b++){
								if(b==0){// Id
									id = (out.Response.Result[a].Data[0].Id);//mms1
									observatories.push(id); //mms1, mms2
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="Coordinates"){//2 times
									//mms1, geo
									var secondvalue = Object.values(out.Response.Result[a].Data[b].Coordinates[0]);
									masterType.push([id, secondvalue[0]]);
									//lines to plot
									
								//	coordinates.push(out.Response.Result[a].Data[b].Coordinates);
									//names of CoordinateSystems, Geo, Gre
									//coordinateSystems.push(out.Response.Result[a].Data[b].Coordinates[0]);
									coordinateLength = out.Response.Result[a].Data[b].Coordinates.length; //length of Data[1] and Data[2]
									//masterType.push(masterSubType); //mms1, geo
									dataLength = (coordinateLength-1)/6; //PROBLEM: May be calculated more than once.
									console.log('dataLength', dataLength);
									//NASA standard: 6 field types in Coordinates.
									for(var q=0;q<dataLength;q++){//sets of 10 to mastertempdata.
										var r=[];
										masterData.push(r);
									}
									console.log('empty masterData', masterData);
									for(var c=0;c<coordinateLength;c++){ //0..61
							//var currentDataPoints = [];
										if(c!=0){//data X, Y, Z, ...
											var currentKey = Object.keys(out.Response.Result[a].Data[b].Coordinates[c]);
											console.log('c', c, 'currentKey', currentKey);
											//X
											if(currentKey[0]!=firstKey){//different field
												console.log('different field-currentKey[0]', currentKey[0]);
												//if(c!=1){//not 1st X					
													console.log('firstKey', firstKey[0]);
													if(masterFields.includes(firstKey[0])==false){
														masterFields.push(firstKey[0]);
														console.log('masterFields pushed', firstKey[0]);
													}
													//masterData.push();
													fieldCount = 0;
												//}
												//if(c==1){
												//	fieldCount = 0;
												//}
												firstKey = currentKey; //X
												var currentValue = Object.values(out.Response.Result[a].Data[b].Coordinates[c]);
												console.log('currentValue', currentValue);
												console.log('fieldCount', fieldCount);
												masterDatatempArray = masterData[fieldCount];
												console.log('masterDatatempArraya', masterDatatempArray);
												masterData[fieldCount].push(currentValue);
												fieldCount++;
											}
											else{
												var currentValue = Object.values(out.Response.Result[a].Data[b].Coordinates[c]);
												console.log('currentValue', currentValue);
												if(c==1){
													//arrangeDataPoints.push();
													
												}
												console.log('fieldCount', fieldCount);
												masterDatatempArray = masterData[fieldCount];
												console.log('masterDatatempArrayb', masterDatatempArray);
												masterData[fieldCount].push(currentValue);
												fieldCount++;
												
											}
										}										
									}
									//masterData.push([]);
									numCoordinates++;
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="Time"){
									masterTime.push(Object.values(out.Response.Result[a].Data[b]));
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="RadialLength"){
									masterRadialLength.push(Object.values(out.Response.Result[a].Data[b]));
								}
							}
						}
						numObservatories++;
					}
					masterSingleDataArrayLength = numDatas*numObservatories*6;
					for(var w=0;w<masterSingleDataArrayLength;w++){
						var tempHolder = [];
						masterSingleDataArray.push(tempHolder);
						//for example, size 24 array.
					}
					console.log('masterSingleDataArrayLength', masterSingleDataArrayLength);
					console.log('numObservatories', numObservatories);
					console.log('observatories', observatories);
					console.log('masterData', masterData);
					console.log('masterFields', masterFields);
					console.log('masterRadialLength', masterRadialLength);
					console.log('masterTime', masterTime);
					console.log('masterType', masterType);
					console.log('masterDatatempArrayc', masterDatatempArray);
					
					for(var t=0;t<masterType.length;t++){
						for(var u=1;u<masterFields.length;u++){ //PROBLEM: Fix the size for 1st index.
							var para = document.createElement("td");
							var node = document.createTextNode(masterType[t]+" "+masterFields[u]);
							para.appendChild(node);
							var element = document.getElementById("fieldnames");
							element.appendChild(para);
						}
					}
					
					var data = [];
					for(var q=0;q<dataLength;q++){
						for(var s=0;s<masterSingleDataArrayLength;s++){
							var dataAdd = {y:[masterData[q][s]], type: 'line'};
							data.push(dataAdd);
						}
					}
					var datapoint = [];
					for(var s=0;s<masterSingleDataArrayLength;s++){
						var datapointAdd = {y:masterData[0][s], type: 'line'};
						datapoint.push(datapointAdd);
						}
					var chartCheck = 0;
					var totalxlength = 500; //display 500 points before sliding
					var indices = [];
						for (var w=0;w<masterSingleDataArrayLength;w++){
							indices.push(w);
						}
					var multipleTraces = [];
					function getData(r, index) {
						return masterData[r][index];
					}  
					Plotly.plot('chart',datapoint);
					var cnt = 0;
					setInterval(function(){
						multipleTraces = [];
						twodecimalPlaces = [];
						if(cnt<dataLength){
							var table = document.getElementById("traces");
							var row = table.insertRow(table.rows.length-1); //insert row at bottom	
						}
						console.log('masterSingleDataArrayLength', masterSingleDataArrayLength);
						for(var r=0;r<masterSingleDataArrayLength;r++){//24 times down by column
							if(cnt<dataLength){
							console.log('getData',getData(cnt,r));
								multipleTraces.push(getData(cnt,r));
							//console.log('dataLength', dataLength);//10
							//console.log('multTracestest1', multipleTraces.length);
							
								if(r==masterSingleDataArrayLength-1){
							//console.log('multTraceestest2', multipleTraces.length);
									for(var a=0;a<dataLength;a++){
										var cellAdd = row.insertCell(a);
							console.log('multipleTraces', multipleTraces[a]);
								//if(multipleTraces.length<dataLength){
										var toChart = multipleTraces[a];
										cellAdd.innerHTML = (toChart);
								//	}
									}
								}
							}
						}
						Plotly.extendTraces('chart',{y:multipleTraces}, indices);
						cnt++;
						if(cnt>totalxlength){
							Plotly.relayout('chart', {
								xaxis: {
									range: [cnt-totalxlength, cnt]
								}
						});
						}
					},200); //update every 200 seconds.
					
					
					
					}
					//--------------testdata2.json-----------------
					//------------github testdata.txt--------------
					else if (testType==1){
					//res.setHeader('Access-Control-Allow-Origin', 'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
					console.log('Status Code: ', out.Result.StatusCode);
					console.log('Status Sub Code: ', out.Result.StatusSubCode);
					keys = Object.keys(out.Result.Data[1][0]);
					console.log('keys = ', keys);
					numKeys = keys.length;
					console.log('numKeys = ', numKeys);
					rawvalues = Object.values(out.Result.Data[1][0]);
					console.log('values = ',rawvalues);
					for(var i=0;i<numKeys;i++){
						var currentrawvalue = rawvalues[i];
						var datarawvalue = [];
						if(keys[i]!="Id"){
							datarawvalue = currentrawvalue[currentrawvalue.length-1];
						}
						else{
							datarawvalue = currentrawvalue;
						}
						keysValues.push([keys[i], datarawvalue]);
					}
					console.log('KeysValues', keysValues);
					//console.log('Output: ', out);
					//myList = JSON.parse(out);
					//return res.json();
	//			})
	//			.catch(err => console.error(err));				
			var chartValuesFields = [];
			var sumChartValues = [];
			var chartValues = [];
			var chartValuesIndex = 0;
			console.log('testc');
			var totalxlength = 0;//500;
			var data = [];//[{y:[getData()], type: 'line'}, {y: [getData()],type: 'line'}, {y: [getData()],type: 'line'}];
			var finalKeyValues = [];
			var finalKeyValuesNum = 0;
			console.log('testd', keysValues[3][1][0]);
			for(var q=0;q<numKeys;q++){
				if(typeof keysValues[q][1][0]==='number'){ //must be numeric type
					if(keysValues[q][1].length>totalxlength){
						totalxlength = keysValues[q][1].length;
					}
					finalKeyValuesNum++;
					finalKeyValues.push(keysValues[q]);
					var counting = 0;
					//data array is initial points
					//for(int y=0;y<totalxlength;y++){ //<17 times
						var dataAdd = {y:[keysValues[q][1][0]], type: 'line'};
						data.push(dataAdd);
					//}
					var addToChartValuesFields = keysValues[q][0]; //may be redundant in for loop, only need once
					chartValuesFields.push(addToChartValuesFields);
					var addToChartValues = keysValues[q][1][0];
					chartValues.push(addToChartValues);
					//console.log('addToChartValuesFields', chartValuesFields);
					//console.log('addToChartValues', chartValues);
					
					//var para = document.createElement("td");
					//var node = document.createTextNode(chartValuesFields);
					//para.appendChild(node);
					//var para2 = document.createElement("p");
					//var node2 = document.createTextNode(chartValues);
					//para2.appendChild(node2);

				}
				//if "Coordinates" special case
			}
			chartValuesIndex++;
			chartValuesIndex++;
			for(var a=0;a<chartValuesFields.length;a++){
console.log('chartValuesFields length', chartValuesFields.length, 'chartValuesFields[a]', chartValuesFields[a]);
				var para = document.createElement("td");
				var node = document.createTextNode(chartValuesFields[a]);
				para.appendChild(node);
				sumChartValues.push(chartValuesFields);
				sumChartValues.push(chartValues);
				var element = document.getElementById("fieldnames");
				element.appendChild(para);
			}
			//element.appendChild(para2);
			console.log('sumChartValues initial', sumChartValues);
			
			Plotly.plot('chart', data);
			var cnt=0;
			var dataindex = 0;
			var multipleTraces = [];
			console.log('finalKeyValuesNum', finalKeyValuesNum);
			
			var indices = [];
			for (var w=0;w<finalKeyValuesNum;w++){
				indices.push(w);
			}
			console.log('indices', indices);
			setInterval(function(){
				multipleTraces = []; //clear
				var table = document.getElementById("traces");
				var row = table.insertRow(table.rows.length-1); //insert row at bottom
				for(var r=0;r<finalKeyValuesNum;r++){//<17 times down by column
					multipleTraces.push([getData(r, dataindex)]);
					
					if(r==finalKeyValuesNum-1){
						for(var a=0;a<multipleTraces.length;a++){
							var cellAdd = row.insertCell(a);
							cellAdd.innerHTML = (multipleTraces[a]);
						}
					}
				}
				//console.log('sumChartValues initial', sumChartValues);
				chartValuesIndex++;
				console.log('multpltraces', multipleTraces);
				/*var para1 = document.createElement("p");
				var node3 = document.createTextNode(addToChartValuesFields);
				para1.appendChild(node);
				var node4 = document.createTextNode(addToChartValues);
				para1.appendChild(node4);
				var element = document.getElementById("bottomchart");
				element.appendChild(para1);
				*///console.log('dataindex', dataindex);
				//console.log('multipleTraces',multipleTraces);
				Plotly.extendTraces('chart',{y:multipleTraces},indices)
				//Plotly.extendTraces('chart',{y:[[getData()]]},[0])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[1])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[2])
				dataindex++;
				cnt++;
				if(cnt>totalxlength){
					Plotly.relayout('chart', {
						xaxis: {
							range: [cnt-totalxlength, cnt]
						}
					});
				}
			},200); //update every 200 seconds.
			var keyIndex = 0;
			var valueIndex = 0;
			function getData(r, dataindex){//keyIndex, valueIndex){
				//for(int r=0;r<totalxlength;r++){ //30 times
				return finalKeyValues[r][1][dataindex];
					//var dataAdd = {y:[getData(q, keysValues[q][1][r])], type: 'line'};
					//data.push(dataAdd);
				//}
				//return Math.random();
			}
		}//testType
		})
				.catch(err => console.error(err));	
	//	}
		</script>
	</div>
	<div id = "bottomchart">
	<p>Table Chart</p>
	<table style="width:100%" id = "traces">
			<tr id = "fieldnames">
			</tr>
			<tr id = "data">
			</tr>
		</table>
	</div>
	</body>
</html>