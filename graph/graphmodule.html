<!DOCTYPE html>
<html>
	<head>
    <meta http-equiv="content-type" content = "text/html; charset= UTF-8"/>

	<script src="plotly.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="xml2json.js"></script>	
	
	<script>

	</script>
	</head>
	<body>
	<div class="navbar"><span>Real-Time Telemetry Data</span></div>
	<div class="wrapper">
		<div id="chart"></div>
		<script src="xml2json.js"></script>
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script>	
			console.log('start');
			var done = false;
			var keys = [];
			var numKeys = 0;
			var rawvalues = [];
			var keysValues = [];
			var json = "";
			//var myList = document.querySelector('ul');
			
			$.ajax({
				method: 'GET',
//WARNING: ALWAYS ADD/REMOVE API KEY
				url: 'https://cors-anywhere.herokuapp.com/https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?',
				success: function(html) {
					console.log('herokutest');
					console.log(html);
				}
			})
			
			var request = new Request(
//			'https://raw.githubusercontent.com/nlee806/temp/master/testdata.txt'); //testType = 1
	// /locations/{observatories}/{timeRange}/{coordinateSystems}/ 
	// {observatories} = a comma separated list of observatory identifiers for which location data is being requested. The values must be from those returned by Get Observatories.
	//{timeRange} = time range for which data location is being requested. There must be two comma separated basic format (minimal number of separators) ISO 8601 date values.
	//{coordinateSystems} = a comma separated list of the names of the coordinate systems in which to represent the returned location information. The values must be from this list: geo, gm, gse, gsm, sm, geitod, geij2000. If no values are given, gse will be assumed. For each coordinate system, the X, Y, Z, Latitude, Longitude, and local-time (if applicable) values will be returned.
	//Satellite observatories: mms1,mms2
	//Time range: 20190101T000000Z,20190101T001000Z
	//Coordinate systems: gse,geo
//WARNING: ALWAYS ADD/REMOVE API KEY testType = 2
			'https://sscweb.sci.gsfc.nasa.gov/WS/sscr/2/locations/mms1,mms2/20190101T000000Z,20190101T001000Z/gse,geo/?');  
			//'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
			//app.get('/YourPath/:parameterName', 
			//function (req, res) {
			fetch(request)//, {mode: 'no-cors', headers: {'Access-Control-Allow-Origin':'*'}})//"same-origin"})//no-cors"})
//				.then(res => res.json()) //testType = 1
				.then(res => res.text()) //testType = 2
				.then(text => {
//				console.log(text);
			//from xmljson_test.html
			function parseXml(xml) {
				var dom = null;
				if (window.DOMParser) {
					try { 
						dom = (new DOMParser()).parseFromString(xml, "text/xml"); 
					} 
					catch (e) { dom = null; }
				}
				else if (window.ActiveXObject) {
					try {
						dom = new ActiveXObject('Microsoft.XMLDOM');
						dom.async = false;
						if (!dom.loadXML(xml)) // parse error ..
							window.alert(dom.parseError.reason + dom.parseError.srcText);
						} 
					catch (e) { dom = null; }
				}
				else
					alert("Error!");
					return dom;
				}
				json = xml2json(parseXml(text), "  ");
				console.log('jsontest');
				console.log(json);
				})
				.then((out) => {
					var testType = 2;
					//--------------testdata2.json ---------------
					if(testType==2){
					out = JSON.parse(json);
					var stringJSON = JSON.stringify(out);
					console.log(typeof(stringJSON));
					console.log('stringJSON', stringJSON);
					//console.log(typeof(out));
					console.log(out.Response.Result[0]);
					console.log(out.Response.Result[1]);
					console.log(out.Response.Result[2]); //2->infinity observatories
					var observatories = [];
					var coordinates = [];
					//numObservatories = number of Datas
					var numObservatories = -2; // -1 to account for StatusCode, StatusSubCode
					var numCoordinates = 0;
					var id = "";
					var masterData = [];
					var masterType = [];
					var masterSubType = [];
					var masterTime = [];
					var masterRadialLength = [];
					var masterFields = [];
					var timeArray = [];
					var radialLengthArray = [];
					var coordinateSystems = [];
					var arrangeDataPoints = [];
					var firstKey = "";
					var fieldCount = 0;
					var numDatas = out.Response.Result.length - 2;
					var coordinateLength = 0;
					console.log('numDatas', numDatas);
					console.log('out.Response.Result.length',out.Response.Result.length);
					console.log('out.Response.Result[2].Data.length',out.Response.Result[2].Data.length);
					
					for(var a=0;a<out.Response.Result.length;a++){ //0123
						numObservatories++;
						if(a>=2){// if, only if is DataArray
							for(var b=0;b<out.Response.Result[a].Data.length;b++){
								if(b==0){// Id
									observatories.push(out.Response.Result[a].Data[0].Id);
									id = (out.Response.Result[a].Data[0].Id);//mms1
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="Coordinates"){//2 times
									numCoordinates++;
									//mms1, geo
									masterType.push([id, out.Response.Result[a].Data[b].Coordinates[0]]);
									coordinates.push(out.Response.Result[a].Data[b].Coordinates);
									//names of CoordinateSystems, Geo, Gre
									//coordinateSystems.push(out.Response.Result[a].Data[b].Coordinates[0]);
									coordinateLength = out.Response.Result[a].Data[b].Coordinates.length;
									//masterType.push(masterSubType); //mms1, geo
									for(var c=0;c<coordinateLength;c++){
							//var currentDataPoints = [];
										if(c!=0){//data X, Y, Z, ...
											var currentKey = Object.keys(out.Response.Result[a].Data[b].Coordinates[c]);
											//X
											if(currentKey!=firstKey){//different field
												if(c!=1){//not 1st X												
													masterFields.push(firstKey);
													//masterData.push();
													fieldCount = 0;
												}
												firstKey = currentKey; //X
											}
											else{
												var currentValue = Object.values(out.Response.Result[a].Data[b].Coordinates[c]);
												masterData[fieldCount].push(currentValue);
												fieldCount++;
											}
										}										
									}
									//masterData.push([]);
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="Time"){
									masterTime.push(Object.values(out.Response.Result[a].Data[b]));
								}
								if(Object.keys(out.Response.Result[a].Data[b])=="RadialLength"){
									masterRadialLength.push(Object.values(out.Response.Result[a].Data[b]));
								}
							}
						}
					}
					console.log('numObservatories', numObservatories);
					console.log('observatories', observatories);
					console.log('masterData', masterData);
					console.log('masterFields', masterFields);
					console.log('masterRadialLength', masterRadialLength);
					console.log('masterTime', masterTime);
					console.log('masterType', masterType);
					
					/*
					function getData() {
						return Math.random();
					}  
					Plotly.plot('chart',[{y:[getData()],type:'line'}]);
					var cnt = 0;
					setInterval(function(){
						Plotly.extendTraces('chart',{ y:[[getData()]]}, [0]);
						cnt++;
					if(cnt > 500) {
						Plotly.relayout('chart',{xaxis: {range: [cnt-500,cnt]}});
					}
					},15);
					*/
					
					}
					//--------------testdata2.json-----------------
					//------------github testdata.txt--------------
					else if (testType==1){
					//res.setHeader('Access-Control-Allow-Origin', 'https://sscweb.sci.gsfc.nasa.gov/WebServices/REST/json/results/themis2.json.txt');
					console.log('Status Code: ', out.Result.StatusCode);
					console.log('Status Sub Code: ', out.Result.StatusSubCode);
					keys = Object.keys(out.Result.Data[1][0]);
					console.log('keys = ', keys);
					numKeys = keys.length;
					console.log('numKeys = ', numKeys);
					rawvalues = Object.values(out.Result.Data[1][0]);
					console.log('values = ',rawvalues);
					for(var i=0;i<numKeys;i++){
						var currentrawvalue = rawvalues[i];
						var datarawvalue = [];
						if(keys[i]!="Id"){
							datarawvalue = currentrawvalue[currentrawvalue.length-1];
						}
						else{
							datarawvalue = currentrawvalue;
						}
						keysValues.push([keys[i], datarawvalue]);
					}
					console.log('KeysValues', keysValues);
					//console.log('Output: ', out);
					//myList = JSON.parse(out);
					//return res.json();
	//			})
	//			.catch(err => console.error(err));				
			var chartValuesFields = [];
			var sumChartValues = [];
			var chartValues = [];
			var chartValuesIndex = 0;
			console.log('testc');
			var totalxlength = 0;//500;
			var data = [];//[{y:[getData()], type: 'line'}, {y: [getData()],type: 'line'}, {y: [getData()],type: 'line'}];
			var finalKeyValues = [];
			var finalKeyValuesNum = 0;
			console.log('testd', keysValues[3][1][0]);
			for(var q=0;q<numKeys;q++){
				if(typeof keysValues[q][1][0]==='number'){ //must be numeric type
					if(keysValues[q][1].length>totalxlength){
						totalxlength = keysValues[q][1].length;
					}
					finalKeyValuesNum++;
					finalKeyValues.push(keysValues[q]);
					var counting = 0;
					//data array is initial points
					//for(int y=0;y<totalxlength;y++){ //<17 times
						var dataAdd = {y:[keysValues[q][1][0]], type: 'line'};
						data.push(dataAdd);
					//}
					var addToChartValuesFields = keysValues[q][0]; //may be redundant in for loop, only need once
					chartValuesFields.push(addToChartValuesFields);
					var addToChartValues = keysValues[q][1][0];
					chartValues.push(addToChartValues);
					//console.log('addToChartValuesFields', chartValuesFields);
					//console.log('addToChartValues', chartValues);
					
					//var para = document.createElement("td");
					//var node = document.createTextNode(chartValuesFields);
					//para.appendChild(node);
					//var para2 = document.createElement("p");
					//var node2 = document.createTextNode(chartValues);
					//para2.appendChild(node2);

				}
				//if "Coordinates" special case
			}
			chartValuesIndex++;
			chartValuesIndex++;
			for(var a=0;a<chartValuesFields.length;a++){
console.log('chartValuesFields length', chartValuesFields.length, 'chartValuesFields[a]', chartValuesFields[a]);
				var para = document.createElement("td");
				var node = document.createTextNode(chartValuesFields[a]);
				para.appendChild(node);
				sumChartValues.push(chartValuesFields);
				sumChartValues.push(chartValues);
				var element = document.getElementById("fieldnames");
				element.appendChild(para);
			}
			//element.appendChild(para2);
			console.log('sumChartValues initial', sumChartValues);
			
			Plotly.plot('chart', data);
			var cnt=0;
			var dataindex = 0;
			var multipleTraces = [];
			console.log('finalKeyValuesNum', finalKeyValuesNum);
			
			var indices = [];
			for (var w=0;w<finalKeyValuesNum;w++){
				indices.push(w);
			}
			console.log('indices', indices);
			setInterval(function(){
				multipleTraces = []; //clear
				var table = document.getElementById("traces");
				var row = table.insertRow(table.rows.length-1); //insert row at bottom
				for(var r=0;r<finalKeyValuesNum;r++){//<17 times down by column
					multipleTraces.push([getData(r, dataindex)]);
					
					if(r==finalKeyValuesNum-1){
						for(var a=0;a<multipleTraces.length;a++){
							var cellAdd = row.insertCell(a);
							cellAdd.innerHTML = (multipleTraces[a]);
						}
					}
				}
				//console.log('sumChartValues initial', sumChartValues);
				chartValuesIndex++;
				console.log('multpltraces', multipleTraces);
				/*var para1 = document.createElement("p");
				var node3 = document.createTextNode(addToChartValuesFields);
				para1.appendChild(node);
				var node4 = document.createTextNode(addToChartValues);
				para1.appendChild(node4);
				var element = document.getElementById("bottomchart");
				element.appendChild(para1);
				*///console.log('dataindex', dataindex);
				//console.log('multipleTraces',multipleTraces);
				Plotly.extendTraces('chart',{y:multipleTraces},indices)
				//Plotly.extendTraces('chart',{y:[[getData()]]},[0])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[1])
				//Plotly.extendTraces('chart',{y:[[getData()]]},[2])
				dataindex++;
				cnt++;
				if(cnt>totalxlength){
					Plotly.relayout('chart', {
						xaxis: {
							range: [cnt-totalxlength, cnt]
						}
					});
				}
			},200); //update every 200 seconds.
			var keyIndex = 0;
			var valueIndex = 0;
			function getData(r, dataindex){//keyIndex, valueIndex){
				//for(int r=0;r<totalxlength;r++){ //30 times
				return finalKeyValues[r][1][dataindex];
					//var dataAdd = {y:[getData(q, keysValues[q][1][r])], type: 'line'};
					//data.push(dataAdd);
				//}
				//return Math.random();
			}
		}//testType
		})
				.catch(err => console.error(err));	
	//	}
		</script>
	</div>
	<div id = "bottomchart">
	<p>Table Chart</p>
	<table style="width:100%" id = "traces">
			<tr id = "fieldnames">
			</tr>
			<tr id = "data">
			</tr>
		</table>
	</div>
	</body>
</html>